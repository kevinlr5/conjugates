buildscript {
    repositories {
        mavenCentral()
        jcenter()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
        classpath("org.asciidoctor:asciidoctor-gradle-plugin:${asciidoctorPluginVersion}")
        classpath("com.bmuschko:gradle-docker-plugin:${dockerPluginVersion}")
    }
}

import com.bmuschko.gradle.docker.DockerRegistryCredentials
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerPushImage
import com.bmuschko.gradle.docker.tasks.image.DockerRemoveImage
import com.bmuschko.gradle.docker.tasks.container.DockerCreateContainer
import com.bmuschko.gradle.docker.tasks.container.DockerInspectContainer
import com.bmuschko.gradle.docker.tasks.container.DockerStartContainer
import com.bmuschko.gradle.docker.tasks.container.DockerStopContainer
import com.bmuschko.gradle.docker.tasks.container.DockerRemoveContainer
import groovy.json.JsonSlurper

apply from: 'git.gradle'

project.version = gitDescribe()

ext {
    gitCommit = gitCommitHash()
    dockerUsername = System.getenv("DOCKER_USERNAME")
    terraformEnvironment = [
        'TF_VAR_aws_access_key_deployment': System.getenv("AWS_ACCESS_KEY_DEPLOYMENT"),
        'TF_VAR_aws_secret_key_deployment': System.getenv("AWS_SECRET_KEY_DEPLOYMENT"),
        'TF_VAR_version': project.version,
        'TF_VAR_deploy_id': project.hasProperty('deployId') ? deployId : project.version.replace(".", ""),
        'TF_VAR_docker_username': dockerUsername
    ]
}

subprojects {
    group = 'org.conjugates'
    version = rootProject.version
    ext {
        dockerUsername = rootProject.dockerUsername
        gitCommit = rootProject.ext.gitCommit
    }
}

task plan(type: Exec) {
    workingDir 'infrastructure/deployment/'
    executable 'terraform'
    args 'plan'
    environment = terraformEnvironment
}

task deploy(type: Exec) {
    workingDir 'infrastructure/deployment/'
    executable 'terraform'
    args 'apply'
    environment = terraformEnvironment
}

task destroyDeploy(type: Exec) {
    workingDir 'infrastructure/deployment/'
    executable 'terraform'
    args = ['destroy', '-force']
    environment = terraformEnvironment
}

project(":analyzer") {
    apply plugin: 'java'
    apply plugin: 'eclipse'
    apply plugin: 'org.springframework.boot'
    apply plugin: 'checkstyle'
    apply plugin: 'org.asciidoctor.convert'
    apply plugin: 'com.bmuschko.docker-remote-api'

    checkstyle {
       toolVersion = checkstyleToolVersion
       configFile = file("${rootProject.projectDir}/config/checkstyle/checkstyle.xml")
    }

    ext {
        snippetsDir = file('build/generated-snippets')
        imageBuildDir = file("${project.buildDir}/image")
    }

    sourceCompatibility = 1.8

    repositories {
        mavenCentral()
    }

    dependencies {
        compile('org.springframework.boot:spring-boot-starter-aop')
        // compile('org.springframework.boot:spring-boot-starter-security')
        compile('org.springframework.boot:spring-boot-starter-web')

        testCompile('org.springframework.boot:spring-boot-starter-test')
        testCompile('org.springframework.restdocs:spring-restdocs-mockmvc')
    }

    task prepareImageBuildDir(type: Copy) {
        from("${project.rootDir}/infrastructure/analyzer") {
            filesMatching("application.properties") { props ->
                props.expand(version: project.version, commit: project.gitCommit)
            }
        }
        from("${project.buildDir}/libs") {
            include '*.jar'
            rename '.*jar', 'app.jar'
        }
        into(imageBuildDir)
    }

    task buildImage(type: DockerBuildImage) {
        dependsOn assemble, prepareImageBuildDir
        inputDir = imageBuildDir
        tag "${dockerUsername}/analyzer:${project.version}"
    }

    task removeImage(type: DockerRemoveImage) {
        targetImageId { buildImage.getImageId() }
    }

    task pushImage(type: DockerPushImage) {
        dependsOn buildImage
        imageName "${dockerUsername}/analyzer"
        tag project.version
        registryCredentials = new DockerRegistryCredentials()
        registryCredentials.username = dockerUsername
        registryCredentials.password = System.getenv("DOCKER_PASSWORD")
    }

    task createContainer(type: DockerCreateContainer) {
        dependsOn pushImage
        targetImageId { buildImage.getImageId() }
        portBindings = ['8080:8080']
    }

    task startContainer(type: DockerStartContainer) {
        dependsOn createContainer
        targetContainerId { createContainer.getContainerId() }
    }

    task stopContainer(type: DockerStopContainer) {
        targetContainerId { createContainer.getContainerId() }
    }

    task removeContainer(type: DockerRemoveContainer) {
        dependsOn stopContainer
        targetContainerId { createContainer.getContainerId() }
    }

    task testContainer() {
        dependsOn startContainer
        doFirst {
            sleep(20000)
        }
        doLast {
            def p = ['curl', "http://localhost:8080/api/info/"].execute()
            def json = new JsonSlurper().parseText(p.text)
            def version = json['version']
            if(version != project.version) {
               throw new RuntimeException("Analyzer didn't start successfully")
            }
        }
        finalizedBy removeContainer, removeImage
    }

    test {
        outputs.dir snippetsDir
    }

    asciidoctor {
        attributes 'snippets': snippetsDir
        inputs.dir snippetsDir
        dependsOn test
    }

    tasks.check.dependsOn testContainer, asciidoctor
    // CIRCLE CI cannot remove docker images/containers
    [tasks.removeContainer, tasks.removeImage].each { t -> t.enabled = !System.getenv("CIRCLECI") }

}
