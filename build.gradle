buildscript {
    repositories {
        mavenCentral()
        jcenter()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
        classpath("com.bmuschko:gradle-docker-plugin:${dockerPluginVersion}")
        classpath("gradle.plugin.com.boxfuse.client:flyway-release:${flywayVersion}")
        classpath("mysql:mysql-connector-java:${mysqlConnectorVersion}")
    }
}

apply from: 'git.gradle'

project.version = gitDescribe()

ext {
    gitCommit = gitCommitHash()
    dockerUsername = System.getenv("DOCKER_USERNAME")
    dbUserPassword = System.getenv("DB_USER_PASSWORD")
    dbHostname = System.getenv("DB_HOSTNAME")
    dbUsername = 'maindbuser'
    deployType = project.hasProperty('deployType') ? project.getProperty('deployType') : 'test'
    deployId = project.hasProperty('deployId') ? project.getProperty('deployId') : createDeployId(deployType)
    schemaName = deployType == 'test' ? "analyzer-${deployId}" : "analyzer-${deployType}"
}

subprojects {
    version = rootProject.version
}

configure(subprojects.findAll {it.name == 'analyzer' || it.name == 'frontend-server'}) {
    apply plugin: 'java'
    apply plugin: 'eclipse'
    apply plugin: 'org.springframework.boot'
    apply plugin: 'checkstyle'
    apply plugin: 'com.bmuschko.docker-remote-api'

    group = 'org.sentiment'

    ext {
        imageBuildDir = file("${project.buildDir}/image")
    }

    checkstyle {
        toolVersion = checkstyleToolVersion
        configFile = file("${rootProject.projectDir}/config/checkstyle/checkstyle.xml")
    }

    sourceCompatibility = 1.8

    repositories {
        mavenCentral()
    }
}

def createRandomNumber() {
    def rnd = new Random()
    return 100000 + rnd.nextInt(900000)
}

def createDeployId(deployType) {
    return deployType + '-' + createRandomNumber()
}

def retry(times, sleepTimeMillis, body) {
  int retries = 0
  def exception = null
  while(retries++ < times) {
    try {
      return body.call()
    } catch(e) {
      exception = e
      println e.message
      sleep(sleepTimeMillis)
    }        
  }
  throw new RuntimeException("Failed after $times tries", exception)
}

def validateHttpEndpoint(url, containerName, validateResponse) {
    def errorMessage = "Waiting for ${containerName} service to start"
    retry(10, 5000) {
        def p = ['curl', url].execute()
        def text = p.text
        if(text.empty) {
            throw new RuntimeException(errorMessage)
        }
        if(!validateResponse(text)) {
            throw new RuntimeException(errorMessage)
        }
    }
}